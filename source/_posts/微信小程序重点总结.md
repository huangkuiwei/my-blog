---
title: 微信小程序重点总结
date: 2018-11-05 21:33:45
author: huangkuiwei
img: http://pic.ossfiles.cn:9186/group1/M00/15/1D/rBgIBlx579L_a7lKAAAf12qXaR0168.jpg
tags: 
    - 微信小程序
    - JavaScript
---
#### 1. 小程序首页
`app.json`文件定义目录路径如下：
```json
{
  "pages": [
    "pages/index/index",
    "pages/logs/logs"
  ]
}
```
写在`pages`字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。上面的首页就是`index`页面。
#### 2. 小程序执行时机和页面执行顺序
以路径`pages/index/index`为例：
>1. 小程序启动之后，在`app.js`定义的`App`实例的`onLaunch`回调会被执行。
>2. 接着会进入`index`页面，微信客户端会先根据`index.json`配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的`WXML`结构和`WXSS`样式。最后客户端会装载`index.js`。你可以看到`index.js`的大体内容就是:
```javascript
  Page({
    data: { // 参与页面渲染的数据
      logs: []
    },
    onLoad: function () {
      // 页面渲染后 执行
    }
  })
```
>3. `Page`是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把`data`数据和`index.wxml`一起渲染出最终的结构，于是就得到了你看到的小程序的样子。
>4. 在渲染完界面之后，页面实例就会收到一个`onLoad`的回调，你可以在这个回调处理你的逻辑。之后就是 onShow、onReady。

#### 3. this.setData()方法使用
`Page.prototype.setData(Object data, Function callback)`：setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。
参数有两个：第一个为一个对象，为这次要改变的数据。第二个为引起的界面更新渲染完毕后的回调函数。
>1. Object 以 key: value 的形式表示，将 this.data 中的 key 对应的值改变成 value。
>2. 其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。
>3. 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。
>4. 仅支持设置可 JSON 化的数据。单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。
>5. 请不要把 data 中任何一项的 value 设为 undefined ，否则这一项将不被设置并可能遗留一些潜在问题。

```javascript
Page({
  data: {
    value1: 'hello world',
    value2: 12,
    info: {
      name: 'huang',
      age: 24
    },
    list: ['huang', 'zhang', 'li', 'wu']
  },
  change() {
    this.setData({
      value1: 'value1 is changed',
      value2: 21,
      'info.age': 88,     // 可通过路径的形式修改某个值
      'list[0]': 'liu'    // 同上
    })
  }
})
```
>1. 补充1：一般情况下，需要用到的数据都要到`data`对象中进行初始化定义（要符合 json 的数据要求），不过如果在`this.setData`中修改了 data 中不存在的数据也是可以在页面上展示的，不过不推荐这样做。
>2. 补充2：页面上使用了 data 中不存在的数据是不会报错的，只是不会展示。

实例：
现在有有一个需求，有九张图片，用户点哪张，哪张图片就要变色（其实就是替换成另外一张图片）
```javascript
Page({
  data: {
    imageList: [
      {
        id: 0,
        image: '/assets/images/prize-bg01.png',
        text: '大气'
      },
      {
        id: 1,
        image: '/assets/images/prize-bg01.png',
        text: '硬扎'
      },
      {
        id: 2,
        image: '/assets/images/prize-bg01.png',
        text: '灵泛'
      }
    ]
  }
})
```
```html
<view class="prize">
  <!-- 循环，不要忘记 wx:key -->
  <view wx:for="{{prizeList}}" wx:key="item.id"> 
    <!-- 通过 data-* 的方式给方法传值 -->
    <image bindtap="getPrize" data-id="{{item.id}}" mode="widthFix" src="{{item.image}}"></image>
    <text>{{item.text}}</text>
  </view>
</view>
```
样式就省略了。现在要写的是`getPrize`方法。
```javascript
getPrize(e) {
  let id = e.target.dataset.id;     // 通过 data-* 传给方法的值 id，再通过 e.target.dataset 拿到组件上传来的所有值。
  this.data.prizeList.map(item => {
    let currentImage = `prizeList[${item.id}].image`;   // 当前 item 的数据路径
    if (item.id === id) {
      this.setData({
        [currentImage]: '/assets/images/prize-bg02.png'
      })
    } else {
      this.setData({
        [currentImage]: '/assets/images/prize-bg01.png'
      })
    }
  })
}
```
![效果图](/medias/postimages/12.gif "效果图")
#### 4. image组件学习
image 组件是展示图片的组件，支持`JPG、JPEG、PNG、SVG、GIF`等常用格式以及`链接、云文件ID`。
相关属性：
>1. `src`: 类型`string`，图片资源地址
>2. `mode`: 类型`string`，默认值`scaleToFill`,图片裁剪、缩放的模式
>3. `lazy-load`: 类型`boolean`，默认值`false`，图片懒加载，在即将进入一定范围（上下三屏）时才开始加载
>4. `show-menu-by-longpress`: 类型`boolean`，默认值`false`，开启长按图片显示识别小程序码菜单	
>5. `binderror`: 类型:`eventhandle`，当加载图片发生错误是触发，`event.detail = {errMsg}`，`errMsg`为错误信息
>6. `bindload`: 类型:`eventhandle`，当图片载入完毕时触发，`event.detail = {height, width}`，`height, width`为图片实际高宽

`mode`的取值：
>1. `scaleToFill`: 缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素。
>2. `aspectFit`: 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。image 组件还是默认大小。
>3. `aspectFill`: 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。image 组件还是默认大小。
>4. `widthFix`: 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变，这个模式最常用。image 组件高度自适应。
>5. 其它模式省略...

补充：
>1. image 组件的默认大小为：`width: 320px; height: 240px`。
>2. image 组件中二维码/小程序码图片默认不支持长按识别。可添加属性`show-menu-by-longpress`，或者在`wx.previewImage`中支持长按识别。

#### 5. wx.previewImage(Object object)
在新页面中全屏预览图片。预览的过程中用户可以进行保存图片、发送给朋友等操作。如果需要用户全屏观看图片，对图片进行操作或者识辨图片中的小程序码可调用此API。
>1. `urls`: Array.<string>,必填，需要预览的图片链接列表。2.2.3 起支持云文件ID。
>2. `current`: string，非必填，urls 的第一张，当前显示图片的链接，没有此参数则默认显示第一张。
>3. `success`: function，非必填，接口调用成功的回调函数
>4. `fail`: function，非必填，接口调用失败的回调函数
>5. `complete`: function，非必填，接口调用结束的回调函数（调用成功、失败都会执行）

实例：
```javascript
Page({
  data: {
    imageList: [
      'http://img9.ph.126.net/6xhfpIcaTzSalcXcBcAZ4Q==/6597438103051957929.jpg',
      'http://hbimg.b0.upaiyun.com/c077851d578f3a6927a59b8da01c209caecfb1855cd2f-D79rMw_fw658',
      'http://photocdn.sohu.com/20120103/Img331047726.jpg',
      'http://img.mp.itc.cn/upload/20170528/2e627839b5fe4d55b04b20d7d893e7a0_th.jpg',
      'https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg'
    ]
  }
})
```
```html
<image bindtap="previewImage" wx:for="{{imageList}}" wx:key="{{index}}" src="{{item}}" data-src="{{item}}"></image>
```
```javascript
previewImage(e) {
  let src = e.target.dataset.src; // 拿到当前的 url 地址
  wx.previewImage({
    urls: this.data.imageList,    // 需要全屏显示的图片数字
    current: src                  // 当前显示的图片（没有此参数，则点击任意一张图片都会显示第一张）
  })
}
```
![效果图](/medias/postimages/13.gif "效果图")
微信模拟器无法长按弹出菜单，实测真机可以。
#### 6. 动态切换元素class属性
动态切换元素 class 属性是我们经常用到的功能，在小程序中没有了 DOM，所以不能在 js 中直接操作 DOM 来完成这个功能，不过可以通过数据间接操纵 DOM。
实现原理的 Vue 框架的思想一样。
```html
<view class="prize">
  <view wx:for="{{prizeList}}" wx:key="item.id">
    <image bindtap="getPrize" data-id="{{item.id}}" mode="widthFix" src="{{item.image}}"></image>
    <text class="{{item.image === '/assets/images/prize-bg02.png' ? 'active' : ''}}">{{item.text}}</text>
  </view>
</view>
```
其它代码参考 **3. this.setData()方法使用** ，这里的class是根据`item.image === '/assets/images/prize-bg02.png'`来进行判断的，如果用户点了该图片，就是被添加一个`active`的 class ，其它的图片就没有这个 class。
#### 7. 数据绑定
WXML 中的动态数据均来自对应 Page 的 data。数据绑定使用 Mustache 语法（双大括号）将变量包起来。
```javascript
Page({
  data: {
    message: 'Hello World',
    num: 24,
    bool: true,
    list: [12, 54, 63, 23],
    info: {
      name: 'huang',
      age: 22
    }
  }
})
```
```html
<view>{{message}}</view>
<view>{{num}}</view>
<view hidden="{{bool}}"></view>
<view wx:for="{{list}}">{{item}} => {{index}}</view>
<view>{{info.name}}</view>
```
组件属性：
```html
<!-- 绑定的属性要用{{}}语法，{{}}内部可以是`JavaScript表达式` -->
<view id="{{message}}"></view>              <!-- id="Hello World" -->
<view id="aaa{{message}}"></view>           <!-- id="aaaHello world" -->
<view id="{{'aaa' +  message}}"></view>     <!-- id="aaaHello World" -->
<!-- 绑定布尔值 -->
<view hidden="{{bool}}"></view>     <!-- 绑定了布尔值，控制元素是否显示 -->
<!-- 或者 -->
<view hidden="{{true}}"></view>
<!-- 一下这种写法 hidden 的值会为 true，绑定了字符串 false，Boolean('false') => true -->
<view hidden="false"></view>
```
非动态绑定（没有绑定 data 中的属性）：
```html
<!-- 绑定字符串 -->
<view id="item"></view>
<view id="{{'item'}}"></view>
<!-- 绑定数字，使用{{}} -->
<view data-id="{{1}}">e.target.dataset.id === 1</view>
<view data-id="1">e.target.dataset.id === '1'</view>
<!-- 绑定布尔值同上 -->
<!-- 绑定数组 -->
<view data-list="{{[1, 2, 3]}}">e.target.dataset.list === [1, 2, 3]</view>
```
绑定对象有点特殊：
```html
<!-- 这样直接绑定对象是会报错的 -->
<view data-info="{{name: 'huang', age: 22}}">报错</view>
<!-- 可以使用 data 对象里面的属性进行绑定 -->
<view data-info="{{info}}">正常</view>
<!-- 如果确实需要传不止一个属性到方法上，可以使用下面这个方法 -->
<view data-name="huang" data-age="{{22}}">e.target.dataset === {{name: 'huang', age: 22}}</view>
```
可以在 WXML 模板（template）上的 data 属性上绑定对象。
```html
<template is="myTemplate" data="{{name: 'huang', age: 24}}"></template>
<!-- 或者：info 在 data 中已经定义 => {name: 'huang', age: 24} -->
<template is="myTemplate" data="{{info}}"></template>
```
组合绑定：
```html
<!-- zero 在 data 中定义 => 0 -->
<view wx:for="{{[zero, 1, 2, 3]}}" wx:key="{{index}}">{{item}}</view>
```
>在`template`模板中同样可以使用组合模式进行数据绑定，如果有相同的属性。后面的属性值会替换前面的属性值。

>注意： 花括号和引号之间如果有空格，将最终被解析成为字符串

```html
<view wx:for="{{[1, 2, 3]}} ">{{item}}</view>
<!-- 等同于 -->
<view wx:for="{{[1, 2, 3] + ' '}}">{{item}}</view>
```
#### 8. 背景图片：background 问题
在小程序中，使用本地的图片设置元素的背景图片是编译不过了，会报错，可以使用网络图片，或者`base64`，或者使用`image`标签。

#### 9. 页面滚动条滚到指定位置
我们平时开发的时候需要页面一进入就自动滚动到指定位置，或者点击某个按钮然后滚动到指定位置。这个时候我们可以用`<scroll-view>`组件。在首页使用`<scroll-view>`组件作为根组件的话会有些问题，在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动，是无法触发 onPullDownRefresh。所以我们需要换一种思路。
`先用`<scroll-view>`组件实现：`
```html
<scroll-view>
  <!-- ...代码省略 -->
  <button>滚动到 id 为 box 的位置</button>
  <!-- ...代码省略 -->
  <view id="box">内容...</view>
  <!-- ...代码省略 -->
</scroll-view>
```
这里我们需要点击按钮，首页就会滚动到 id="box" 的地方。根据`<scroll-view>`的用法，要先给`<scroll-view>`设置一个高度，然后设置属性`scroll-x`或者`scroll-y`。
```css
/* page 元素为当前页面根元素 */
page {
  height: 100%;
}
/* scroll-view 的高度就是当前页面的可见高度 */
scroll-view {
  height: 100%;
}
```
```html
<scroll-view scroll-x scroll-into-view="{{scrollPosition}}">
  <!-- ...代码省略 -->
  <button bindtap="scrollToBox">滚动到 id 为 box 的位置</button>
  <!-- ...代码省略 -->
  <view id="box">内容...</view>
  <!-- ...代码省略 -->
</scroll-view>
```
```javascript
page({
  data: {
    scrollPosition: ''
  },
  scrollToBox(){
    this.setData({
      scrollPosition: 'box'
    })
  }
})
```
**另外一种方法，不需要使用`scroll-view`组件**：
```javascript
scrollToBox() {
  wx.createSelectorQuery().select('#box').boundingClientRect(rect => {
    wx.pageScrollTo({
      scrollTop: rect.top
    })
  }).exec()
}
```
#### 10. wx.createSelectorQuery()
返回一个 SelectorQuery 对象实例。在自定义组件或包含自定义组件的页面中，应使用 this.createSelectorQuery() 来代替。
```javascript
let query = wx.createSelectorQuery();       // 创建节点查询器 query
query.select('#box').boundingClientRect();  // 选择id=the-id的节点，获取节点位置信息的查询请求
query.selectViewport().scrollOffset();      // 获取页面滑动位置的查询请求
query.exec(res => {
  console.log(res[0]);     // 第一个请求结果
  console.log(res[1])      // 第二个请求结果
})
```
>注意：`exec`方法执行所有的请求。请求结果按请求次序构成数组，在callback的第一个参数中返回。如果没有执行这个方法，则 boundingClientRect() 等方法的回调函数函数不会执行。

#### 10. wx.pageScrollTo(Object object)
将页面滚动到目标位置。
>1. `scrollTop`，number，必填，滚动到页面的目标位置，单位 px
>2. `duration`，number，默认300mm，非必填，滚动动画的时长，单位 ms
>3. `success`，function，非必填，接口调用成功的回调函数
>4. `fail`，function，非必填	接口调用失败的回调函数
>5. `complete`，function，非必填，接口调用结束的回调函数（调用成功、失败都会执行）

```javascript
wx.pageScrollTo({
  scrollTop: 0,
  duration: 300
})
```












